## plot campo stimato ----
plot(est_field_adaptive$x, type = "n", xlab = "X", ylab = "Y", main = "Estimated Vector Field")
arrows(est_field_adaptive$x[,1], est_field_adaptive$x[,2],
est_field_adaptive$x[,1] + est_field_adaptive$estimator[,1],
est_field_adaptive$x[,2] + est_field_adaptive$estimator[,2],
length = 0.05, angle = 15, col = "blue")
## plot errore ----
VFx = t(apply(x, 1, VF))
plot(est_field_adaptive$x, type = "n", xlab = "X", ylab = "Y", main = "Error Vector Field")
arrows(est_field_adaptive$x[,1], est_field_adaptive$x[,2],
est_field_adaptive$x[,1] + est_field_adaptive$estimator[,1] - VFx[,1],
est_field_adaptive$x[,2] + est_field_adaptive$estimator[,2] - VFx[,2],
length = 0.05, angle = 15, col = "red")
## image errore ----
library(fields)
errorNorm = sqrt((est_field_adaptive$estimator[,1] - VFx[,1])^2 + (est_field_adaptive$estimator[,2] - VFx[,2])^2)
image.plot(x = unique(x[,1]), y = unique(x[,2]), z = matrix(log10(errorNorm), nrow=sqrt(nEval), ncol=sqrt(nEval)),xlab="x",ylab="y",main="error norm (log10)")
X0
cov(X0)
inv(cov(X0))
solve(cov(X0))
sqrt(solve(cov(X0)))
sqrtm(solve(cov(X0)))
library(exp,m)
library(expm)
library(exp,m)
sqrtm(solve(cov(X0)))
diag(2)
source("~/Library/CloudStorage/OneDrive-UniversityofPisa/timeSpaceEvolutionEcAct/RVF/R code/Vector Field Estimation/src/libs/kernel.R", echo=TRUE)
nObs = 10000
set.seed(123)
X_0_Gauss = mvrnorm(nObs, mu=c(0,0),Sigma = 1*diag(2))
# Create evaluation grid for density estimation and regression
nEval = 2500
xGrid = seq(from=min(X_0_Gauss[,1]), to=max(X_0_Gauss[,1]), length.out=round(sqrt(nEval)))
yGrid = seq(from=min(X_0_Gauss[,2]), to=max(X_0_Gauss[,2]), length.out=round(sqrt(nEval)))
x = as.matrix(expand.grid(xGrid, yGrid))
mean = c(0, 0)
sigma = matrix(c(1, 0, 0, 1), nrow=2)
trueGaussian = dmvnorm(x, mean, sigma)
suppressPackageStartupMessages(library(mvtnorm))
trueGaussian = dmvnorm(x, mean, sigma)
# ---- Density Estimation Tests ----
print("#---- Density Estimation Tests ----")
print("We start by testing the fixed bandwidth density estimation against the sm package")
print("================================================")
print(paste("Number of observations:", nObs))
print(paste("Number of evaluation points:", nEval))
print("================================================")
print("Estimating a standard Gaussian")
bandwidth = 0.5
print(paste(" Gaussian kernel", "bandwidth =", bandwidth))
X = X_0_Gauss
h = bandwidth
kernel.type = "gauss"
sparse=FALSE
gc=TRUE
type.est = "density"
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
chunk_size = 1000
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
lambda = NULL
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
method.h=NULL
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
resultEstCULO = kernelMethodCULO(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
source("~/Library/CloudStorage/OneDrive-UniversityofPisa/timeSpaceEvolutionEcAct/RVF/R code/Vector Field Estimation/src/libs/kernel.R", echo=TRUE)
resultEstCULO = kernelMethodCULO(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
kernelMethodCULO
resultEst$x == resultEstCULO$x
resultEst$estimator == resultEstCULO$estimator
resultEst$estimator
resultEstCULO$estimator
resultEst$estimator
resultEstCULO$estimator
resultEst$estimator
resultEstCULO$estimator
resultEst$estimator
resultEstCULO$estimator
resultEstCULO$estimator - resultEst$estimator
# X_0_Gauss = mvrnorm(nObs, mu=c(0,0),Sigma = 1*diag(2))
X_0_Gauss = mvrnorm(nObs, mu=c(0,0),Sigma = matrix(c(1, 0.5, 0.5, 1), nrow=2))
plot(X_0_Gauss)
# X_0_Gauss = mvrnorm(nObs, mu=c(0,0),Sigma = 1*diag(2))
X_0_Gauss = mvrnorm(nObs, mu=c(0,0),Sigma = matrix(c(0.5, 0.5, 0.5, 0.5), nrow=2))
plot(X_0_Gauss)
# X_0_Gauss = mvrnorm(nObs, mu=c(0,0),Sigma = 1*diag(2))
X_0_Gauss = mvrnorm(nObs, mu=c(0,0),Sigma = matrix(c(0.75, 0.5, 0.5, 0.75), nrow=2))
plot(X_0_Gauss)
nEval = 2500
xGrid = seq(from=min(X_0_Gauss[,1]), to=max(X_0_Gauss[,1]), length.out=round(sqrt(nEval)))
yGrid = seq(from=min(X_0_Gauss[,2]), to=max(X_0_Gauss[,2]), length.out=round(sqrt(nEval)))
x = as.matrix(expand.grid(xGrid, yGrid))
mean = c(0, 0)
sigma = matrix(c(1, 0, 0, 1), nrow=2)
trueGaussian = dmvnorm(x, mean, sigma)
# ---- Density Estimation Tests ----
print("#---- Density Estimation Tests ----")
print("We start by testing the fixed bandwidth density estimation against the sm package")
print("================================================")
print(paste("Number of observations:", nObs))
print(paste("Number of evaluation points:", nEval))
print("================================================")
print("Estimating a standard Gaussian")
bandwidth = 0.5
print(paste(" Gaussian kernel", "bandwidth =", bandwidth))
X = X_0_Gauss
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
resultEstCULO = kernelMethodCULO(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
resultEstCULO$estimator - resultEst$estimator
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
resultEstCULO = kernelMethodCULO(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
source("~/Library/CloudStorage/OneDrive-UniversityofPisa/timeSpaceEvolutionEcAct/RVF/R code/Vector Field Estimation/src/libs/kernel.R", echo=TRUE)
resultEstCULO = kernelMethodCULO(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
resultEstCULO$estimator - resultEst$estimator
image(resultEstCULO$estimator - resultEst$estimator)
source("~/Library/CloudStorage/OneDrive-UniversityofPisa/timeSpaceEvolutionEcAct/RVF/R code/Vector Field Estimation/src/libs/kernel.R", echo=TRUE)
resultEstCULO = kernelMethodCULO(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
resultEstCULO$estimator - resultEst$estimator
nObs = 10
set.seed(123)
# X_0_Gauss = mvrnorm(nObs, mu=c(0,0),Sigma = 1*diag(2))
X_0_Gauss = mvrnorm(nObs, mu=c(0,0),Sigma = matrix(c(0.75, 0.5, 0.5, 0.75), nrow=2))
# Create evaluation grid for density estimation and regression
nEval = 2500
xGrid = seq(from=min(X_0_Gauss[,1]), to=max(X_0_Gauss[,1]), length.out=round(sqrt(nEval)))
yGrid = seq(from=min(X_0_Gauss[,2]), to=max(X_0_Gauss[,2]), length.out=round(sqrt(nEval)))
x = as.matrix(expand.grid(xGrid, yGrid))
mean = c(0, 0)
sigma = matrix(c(1, 0, 0, 1), nrow=2)
trueGaussian = dmvnorm(x, mean, sigma)
nObs = 10
set.seed(123)
# Sigma = matrix(c(1, 0, 0, 1), nrow=2)
Sigma = matrix(c(0.75, 0.5, 0.5, 0.75), nrow=2)
X_0_Gauss = mvrnorm(nObs, mu=c(0,0),Sigma = Sigma)
# Create evaluation grid for density estimation and regression
nEval = 2500
xGrid = seq(from=min(X_0_Gauss[,1]), to=max(X_0_Gauss[,1]), length.out=round(sqrt(nEval)))
yGrid = seq(from=min(X_0_Gauss[,2]), to=max(X_0_Gauss[,2]), length.out=round(sqrt(nEval)))
x = as.matrix(expand.grid(xGrid, yGrid))
mean = c(0, 0)
trueGaussian = dmvnorm(x, mean, Sigma)
print("#---- Density Estimation Tests ----")
print("We start by testing the fixed bandwidth density estimation against the sm package")
print("================================================")
print(paste("Number of observations:", nObs))
print(paste("Number of evaluation points:", nEval))
print("================================================")
print("Estimating a standard Gaussian")
bandwidth = 0.5
print(paste(" Gaussian kernel", "bandwidth =", bandwidth))
X = X_0_Gauss
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
X
# Generate random normal data for source distribution
nObs = 10000
set.seed(123)
# Sigma = matrix(c(1, 0, 0, 1), nrow=2)
Sigma = matrix(c(0.75, 0.5, 0.5, 0.75), nrow=2)
X_0_Gauss = mvrnorm(nObs, mu=c(0,0),Sigma = Sigma)
# Create evaluation grid for density estimation and regression
nEval = 10
xGrid = seq(from=min(X_0_Gauss[,1]), to=max(X_0_Gauss[,1]), length.out=round(sqrt(nEval)))
yGrid = seq(from=min(X_0_Gauss[,2]), to=max(X_0_Gauss[,2]), length.out=round(sqrt(nEval)))
x = as.matrix(expand.grid(xGrid, yGrid))
mean = c(0, 0)
trueGaussian = dmvnorm(x, mean, Sigma)
# ---- Density Estimation Tests ----
print("#---- Density Estimation Tests ----")
print("We start by testing the fixed bandwidth density estimation against the sm package")
print("================================================")
print(paste("Number of observations:", nObs))
print(paste("Number of evaluation points:", nEval))
print("================================================")
print("Estimating a standard Gaussian")
bandwidth = 0.5
print(paste(" Gaussian kernel", "bandwidth =", bandwidth))
estGaussian <- densityEst2d(X_0_Gauss, x=x, h=bandwidth, kernel.type = "gauss", sparse=FALSE, gc=TRUE)
X = X_0_Gauss
X
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
D_chunk = computeDcomponents(X, x, sparse=sparse)
nObs = nrow(X)
covX = cov(X)
invS = solve(covX)
sqrtinvS = sqrtm(solve(covX))
detS = det(covX)
D_chunkCULO = computeDcomponents(Z, z, sparse=sparse)
Z = X %*% sqrtinvS
z = x %*% sqrtinvS
D_chunkCULO = computeDcomponents(Z, z, sparse=sparse)
D_chunkCULO
D_chunk
D_chunkCULO
D_chunk
D_chunkCULO
D_chunk
M = mahalanobis(D_chunk$z1, D_chunk$z2, A=diag(2), den=h^2 * lambda^2)
M = mahalanobis(D_chunk$z1, D_chunk$z2, A=invS, den=h^2 * lambda^2)
D_chunk
M = mahalanobis(D_chunk$z1, D_chunk$z2, A=invS, den=h^2 * lambda^2)
invS
sqrtinvS
M
invS
h
lambda
lambda =1
M = mahalanobis(D_chunk$z1, D_chunk$z2, A=invS, den=h^2 * lambda^2)
M
MCULO = mahalanobis(D_chunkCULO$z1, D_chunkCULO$z2, A=diag(2), den=h^2 * lambda^2)
M
M - MCULO
# Kernel computation
K = kernelFunction(M)
kernelFunction = defineKernel(kernel.type)
# Kernel computation
K = kernelFunction(M)
K_scaled = sweep(K, 1, lambda^2, "/")
computeTerms(Z, Y, h, detS, K_scaled, type.est)
# Clear workspace and load dependencies
rm(list = ls())
DEBUG = TRUE
source("libs/loadLib.R")
source("libs/codeMunicipalities.R")
suppressPackageStartupMessages(library(plotly))
suppressPackageStartupMessages(library(sm))
suppressPackageStartupMessages(library(mvtnorm))
# ---- Data Generation ----
# Generate random normal data for source distribution
nObs = 10000
set.seed(123)
# Sigma = matrix(c(1, 0, 0, 1), nrow=2)
Sigma = matrix(c(0.75, 0.5, 0.5, 0.75), nrow=2)
X_0_Gauss = mvrnorm(nObs, mu=c(0,0),Sigma = Sigma)
# Create evaluation grid for density estimation and regression
nEval = 10
xGrid = seq(from=min(X_0_Gauss[,1]), to=max(X_0_Gauss[,1]), length.out=round(sqrt(nEval)))
yGrid = seq(from=min(X_0_Gauss[,2]), to=max(X_0_Gauss[,2]), length.out=round(sqrt(nEval)))
x = as.matrix(expand.grid(xGrid, yGrid))
mean = c(0, 0)
trueGaussian = dmvnorm(x, mean, Sigma)
# ---- Density Estimation Tests ----
print("#---- Density Estimation Tests ----")
print("We start by testing the fixed bandwidth density estimation against the sm package")
print("================================================")
print(paste("Number of observations:", nObs))
print(paste("Number of evaluation points:", nEval))
print("================================================")
print("Estimating a standard Gaussian")
bandwidth = 0.5
print(paste(" Gaussian kernel", "bandwidth =", bandwidth))
X = X_0_Gauss
kernel.type="gauss"
method.h=NULL
h=NULL
lambda=NULL
sparse=FALSE
gc=FALSE
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
chunk_size  = 1000
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
type.est = "density"
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
resultEstCULO = kernelMethodCULO(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
resultEstCULO$estimator - resultEst$estimator
# Clear workspace and load dependencies
rm(list = ls())
DEBUG = TRUE
source("libs/loadLib.R")
source("libs/codeMunicipalities.R")
suppressPackageStartupMessages(library(plotly))
suppressPackageStartupMessages(library(sm))
suppressPackageStartupMessages(library(mvtnorm))
# ---- Data Generation ----
# Generate random normal data for source distribution
nObs = 10000
set.seed(123)
# Sigma = matrix(c(1, 0, 0, 1), nrow=2)
Sigma = matrix(c(0.75, 0.5, 0.5, 0.75), nrow=2)
X_0_Gauss = mvrnorm(nObs, mu=c(0,0),Sigma = Sigma)
# Create evaluation grid for density estimation and regression
nEval = 2500
xGrid = seq(from=min(X_0_Gauss[,1]), to=max(X_0_Gauss[,1]), length.out=round(sqrt(nEval)))
yGrid = seq(from=min(X_0_Gauss[,2]), to=max(X_0_Gauss[,2]), length.out=round(sqrt(nEval)))
x = as.matrix(expand.grid(xGrid, yGrid))
mean = c(0, 0)
trueGaussian = dmvnorm(x, mean, Sigma)
# ---- Density Estimation Tests ----
print("#---- Density Estimation Tests ----")
print("We start by testing the fixed bandwidth density estimation against the sm package")
print("================================================")
print(paste("Number of observations:", nObs))
print(paste("Number of evaluation points:", nEval))
print("================================================")
print("Estimating a standard Gaussian")
bandwidth = 0.5
X = X_0_Gauss
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
chunk_size = 1000
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
lambda = NULL
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
type.est = "density"
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
h=NULL
ambda=NULL
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
method.h=NULL
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
kernel.type="gauss"
lambda=NULL
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
sparse=FALSE
gc=FALSE
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
resultEstCULO = kernelMethodCULO(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
resultEst$estimator - resultEstCULO$estimator
setwd("~/Library/CloudStorage/OneDrive-UniversityofPisa/timeSpaceEvolutionEcAct/RVF/R code/Vector Field Estimation/src")
rm(list = ls())
# parameters ----
nObs = 100
nT = 10
# data Generation ----
set.seed(1)
# genero i FE
alpha_i = mvrnorm(nObs,mu=c(0,0),Sigma=0.01*diag(2))
library(MASS)
rm(list = ls())
library(MASS)
# parameters ----
nObs = 100
nT = 10
# data Generation ----
set.seed(1)
# genero i FE
alpha_i = mvrnorm(nObs,mu=c(0,0),Sigma=0.01*diag(2))
alpha_i[,1] = alpha_i[,1] - sum(alpha_i[,1])/nObs
alpha_i[,2] = alpha_i[,2] - sum(alpha_i[,2])/nObs
# genero i TE
gamma_t = mvrnorm(nT,mu=c(0,0),Sigma=0.01*diag(2))
gamma_t[,1] = gamma_t[,1] - sum(gamma_t[,1])/nT
gamma_t[,2] = gamma_t[,2] - sum(gamma_t[,2])/nT
X0 = mvrnorm(nObs, mu=c(0,0),Sigma = 0.25*diag(2)) + alpha_i + array(rep(gamma_t[1,],each=nObs),dim=c(nObs,2))
X = array(NA,dim = c(nObs,2,nT+1))
X[,,1] = X0
# example 1 - double well ----
VF <- function(X){
# X = (x,y)
# U(X) = x^4 - x^2 + y^2
# VF(X) = -grad U(X) = -(4x^3 - 2x, 2y)
return( -0.01*c(4*X[1]^3 - 2*X[1], 2*X[2]) )
}
# example 2 -- single well ----
# VF <- function(X){
#     # X = (x,y)
#     # U(X) = x^2 + y^2
#     # VF(X) = -grad U(X) = -(2x, 2y)
#     return( -0.1*c(2*X[1], 2*X[2]) )
# }
# example 3 -- rotation ----
# M = matrix(c(cos(pi/2), -sin(pi/2), sin(pi/2), cos(pi/2)),nrow=2,ncol=2)
# VF <- function(X){
#     # X = (x,y), theta = pi/4
#     return (0.1*(M %*% X - X))
# }
for (t in 1:nT){
X[,,t+1] = X[,,t] + t(apply(X[,,t], 1, VF)) + alpha_i + array(rep(gamma_t[t,],each=nObs),dim=c(nObs,2)) +
+ mvrnorm(nObs, mu=c(0,0),Sigma = 0.001*diag(2))
}
# calcolo i Delta
Delta = (X[,,2:(nT+1)] - X[,,1:nT])
# la variabile dipendente è Delta di dimensione:
dim(Delta)
X0 = X[,,1:nT]
dim(X0)
# Clear workspace and load dependencies
setwd("~/Library/CloudStorage/OneDrive-UniversityofPisa/timeSpaceEvolutionEcAct/RVF/R code/Vector Field Estimation/")
rm(list = ls())
graphics.off()
dev.new()
DEBUG = FALSE
source("src/libs/loadLib.R")
library(fields)
library(latex2exp)
# parameters ----
nObs = 100
nT = 10
nEval = 2500
# eval points
xGrid = seq(from=-1, to=1, length.out=round(sqrt(nEval)))
yGrid = seq(from=-1, to=1, length.out=round(sqrt(nEval)))
x = as.matrix(expand.grid(xGrid, yGrid))
# data Generation ----
set.seed(1)
# genero i FE
alpha_i = mvrnorm(nObs,mu=c(0,0),Sigma=0.01*diag(2))
alpha_i[,1] = alpha_i[,1] - sum(alpha_i[,1])/nObs
alpha_i[,2] = alpha_i[,2] - sum(alpha_i[,2])/nObs
# alpha_i = matrix(0,nrow=nObs,ncol=2)
# genero i TE
gamma_t = mvrnorm(nT,mu=c(0,0),Sigma=0.01*diag(2))
gamma_t[,1] = gamma_t[,1] - sum(gamma_t[,1])/nT
gamma_t[,2] = gamma_t[,2] - sum(gamma_t[,2])/nT
# gamma_t = matrix(0,nrow = nT, ncol = 2)
X0 = mvrnorm(nObs, mu=c(0,0),Sigma = 0.25*diag(2)) + alpha_i + array(rep(gamma_t[1,],each=nObs),dim=c(nObs,2))
X = array(NA,dim = c(nObs,2,nT+1))
X[,,1] = X0
# example 1 - double well ----
# VF <- function(X){
#     # X = (x,y)
#     # U(X) = x^4 - x^2 + y^2
#     # VF(X) = -grad U(X) = -(4x^3 - 2x, 2y)
#     return( -0.01*c(4*X[1]^3 - 2*X[1], 2*X[2]) )
# }
# example 2 -- single well ----
# VF <- function(X){
#     # X = (x,y)
#     # U(X) = x^2 + y^2
#     # VF(X) = -grad U(X) = -(2x, 2y)
#     return( -0.05*c(2*X[1], 2*X[2]) )
# }
# example 3 -- rotation ----
M = matrix(c(cos(pi/2), -sin(pi/2), sin(pi/2), cos(pi/2)),nrow=2,ncol=2)
VF <- function(X){
# X = (x,y), theta = pi/4
return (0.1*(M %*% X - X))
}
for (t in 1:nT){
X[,,t+1] = X[,,t] + t(apply(X[,,t], 1, VF)) + alpha_i + array(rep(gamma_t[t,],each=nObs),dim=c(nObs,2)) +
+ mvrnorm(nObs, mu=c(0,0),Sigma = 0.001*diag(2))
}
# calcolo i Delta
Delta = (X[,,2:(nT+1)] - X[,,1:nT])
# demeaning per i FE
MeanDelta_i = apply(Delta, c(1, 2), mean)
MeanDelta_t = apply(Delta, c(2, 3), mean)
DeltaFE = Delta - array(rep(MeanDelta_i, nT), dim = c(nObs, 2, nT))  +
- array(rep(MeanDelta_t, each = nObs), dim = c(nObs, 2, nT))  +
+ aperm(array(rep(apply(Delta, 2, mean),nObs*nT),dim = c(2,nObs,nT)),c(2,1,3))
# DeltaFE = Delta
# metto in formato input per il VF
DeltaFEStack = do.call(rbind, lapply(1:nT, function(t) DeltaFE[,,t]))
X0Stack = do.call(rbind, lapply(1:nT, function(t) X[,,t]))
X1Stack = X0Stack + DeltaFEStack
# diagnostic on means
MX = array(NA, dim = c(nObs, 2, nT))
for (t in 1:nT){
MX[,,t] = t(apply(X[,,t], 1, VF))
}
meanMX_i = apply(MX, c(1, 2), mean)
meanMX_t = apply(MX, c(2, 3), mean)
summary(meanMX_i)
summary(t(meanMX_t))
# stima ----
# est_field_adaptive = NWfieldAdaptive(X0Stack, X1Stack, x=x, kernel.type="gauss", hOpt = FALSE, alphaOpt = FALSE, chunk_size = 1000)
dim(X0Stack)
