chunk_size = 1000
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
lambda = NULL
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
method.h=NULL
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
resultEstCULO = kernelMethodCULO(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
source("~/Library/CloudStorage/OneDrive-UniversityofPisa/timeSpaceEvolutionEcAct/RVF/R code/Vector Field Estimation/src/libs/kernel.R", echo=TRUE)
resultEstCULO = kernelMethodCULO(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
kernelMethodCULO
resultEst$x == resultEstCULO$x
resultEst$estimator == resultEstCULO$estimator
resultEst$estimator
resultEstCULO$estimator
resultEst$estimator
resultEstCULO$estimator
resultEst$estimator
resultEstCULO$estimator
resultEst$estimator
resultEstCULO$estimator
resultEstCULO$estimator - resultEst$estimator
# X_0_Gauss = mvrnorm(nObs, mu=c(0,0),Sigma = 1*diag(2))
X_0_Gauss = mvrnorm(nObs, mu=c(0,0),Sigma = matrix(c(1, 0.5, 0.5, 1), nrow=2))
plot(X_0_Gauss)
# X_0_Gauss = mvrnorm(nObs, mu=c(0,0),Sigma = 1*diag(2))
X_0_Gauss = mvrnorm(nObs, mu=c(0,0),Sigma = matrix(c(0.5, 0.5, 0.5, 0.5), nrow=2))
plot(X_0_Gauss)
# X_0_Gauss = mvrnorm(nObs, mu=c(0,0),Sigma = 1*diag(2))
X_0_Gauss = mvrnorm(nObs, mu=c(0,0),Sigma = matrix(c(0.75, 0.5, 0.5, 0.75), nrow=2))
plot(X_0_Gauss)
nEval = 2500
xGrid = seq(from=min(X_0_Gauss[,1]), to=max(X_0_Gauss[,1]), length.out=round(sqrt(nEval)))
yGrid = seq(from=min(X_0_Gauss[,2]), to=max(X_0_Gauss[,2]), length.out=round(sqrt(nEval)))
x = as.matrix(expand.grid(xGrid, yGrid))
mean = c(0, 0)
sigma = matrix(c(1, 0, 0, 1), nrow=2)
trueGaussian = dmvnorm(x, mean, sigma)
# ---- Density Estimation Tests ----
print("#---- Density Estimation Tests ----")
print("We start by testing the fixed bandwidth density estimation against the sm package")
print("================================================")
print(paste("Number of observations:", nObs))
print(paste("Number of evaluation points:", nEval))
print("================================================")
print("Estimating a standard Gaussian")
bandwidth = 0.5
print(paste(" Gaussian kernel", "bandwidth =", bandwidth))
X = X_0_Gauss
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
resultEstCULO = kernelMethodCULO(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
resultEstCULO$estimator - resultEst$estimator
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
resultEstCULO = kernelMethodCULO(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
source("~/Library/CloudStorage/OneDrive-UniversityofPisa/timeSpaceEvolutionEcAct/RVF/R code/Vector Field Estimation/src/libs/kernel.R", echo=TRUE)
resultEstCULO = kernelMethodCULO(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
resultEstCULO$estimator - resultEst$estimator
image(resultEstCULO$estimator - resultEst$estimator)
source("~/Library/CloudStorage/OneDrive-UniversityofPisa/timeSpaceEvolutionEcAct/RVF/R code/Vector Field Estimation/src/libs/kernel.R", echo=TRUE)
resultEstCULO = kernelMethodCULO(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
resultEstCULO$estimator - resultEst$estimator
nObs = 10
set.seed(123)
# X_0_Gauss = mvrnorm(nObs, mu=c(0,0),Sigma = 1*diag(2))
X_0_Gauss = mvrnorm(nObs, mu=c(0,0),Sigma = matrix(c(0.75, 0.5, 0.5, 0.75), nrow=2))
# Create evaluation grid for density estimation and regression
nEval = 2500
xGrid = seq(from=min(X_0_Gauss[,1]), to=max(X_0_Gauss[,1]), length.out=round(sqrt(nEval)))
yGrid = seq(from=min(X_0_Gauss[,2]), to=max(X_0_Gauss[,2]), length.out=round(sqrt(nEval)))
x = as.matrix(expand.grid(xGrid, yGrid))
mean = c(0, 0)
sigma = matrix(c(1, 0, 0, 1), nrow=2)
trueGaussian = dmvnorm(x, mean, sigma)
nObs = 10
set.seed(123)
# Sigma = matrix(c(1, 0, 0, 1), nrow=2)
Sigma = matrix(c(0.75, 0.5, 0.5, 0.75), nrow=2)
X_0_Gauss = mvrnorm(nObs, mu=c(0,0),Sigma = Sigma)
# Create evaluation grid for density estimation and regression
nEval = 2500
xGrid = seq(from=min(X_0_Gauss[,1]), to=max(X_0_Gauss[,1]), length.out=round(sqrt(nEval)))
yGrid = seq(from=min(X_0_Gauss[,2]), to=max(X_0_Gauss[,2]), length.out=round(sqrt(nEval)))
x = as.matrix(expand.grid(xGrid, yGrid))
mean = c(0, 0)
trueGaussian = dmvnorm(x, mean, Sigma)
print("#---- Density Estimation Tests ----")
print("We start by testing the fixed bandwidth density estimation against the sm package")
print("================================================")
print(paste("Number of observations:", nObs))
print(paste("Number of evaluation points:", nEval))
print("================================================")
print("Estimating a standard Gaussian")
bandwidth = 0.5
print(paste(" Gaussian kernel", "bandwidth =", bandwidth))
X = X_0_Gauss
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
X
# Generate random normal data for source distribution
nObs = 10000
set.seed(123)
# Sigma = matrix(c(1, 0, 0, 1), nrow=2)
Sigma = matrix(c(0.75, 0.5, 0.5, 0.75), nrow=2)
X_0_Gauss = mvrnorm(nObs, mu=c(0,0),Sigma = Sigma)
# Create evaluation grid for density estimation and regression
nEval = 10
xGrid = seq(from=min(X_0_Gauss[,1]), to=max(X_0_Gauss[,1]), length.out=round(sqrt(nEval)))
yGrid = seq(from=min(X_0_Gauss[,2]), to=max(X_0_Gauss[,2]), length.out=round(sqrt(nEval)))
x = as.matrix(expand.grid(xGrid, yGrid))
mean = c(0, 0)
trueGaussian = dmvnorm(x, mean, Sigma)
# ---- Density Estimation Tests ----
print("#---- Density Estimation Tests ----")
print("We start by testing the fixed bandwidth density estimation against the sm package")
print("================================================")
print(paste("Number of observations:", nObs))
print(paste("Number of evaluation points:", nEval))
print("================================================")
print("Estimating a standard Gaussian")
bandwidth = 0.5
print(paste(" Gaussian kernel", "bandwidth =", bandwidth))
estGaussian <- densityEst2d(X_0_Gauss, x=x, h=bandwidth, kernel.type = "gauss", sparse=FALSE, gc=TRUE)
X = X_0_Gauss
X
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
D_chunk = computeDcomponents(X, x, sparse=sparse)
nObs = nrow(X)
covX = cov(X)
invS = solve(covX)
sqrtinvS = sqrtm(solve(covX))
detS = det(covX)
D_chunkCULO = computeDcomponents(Z, z, sparse=sparse)
Z = X %*% sqrtinvS
z = x %*% sqrtinvS
D_chunkCULO = computeDcomponents(Z, z, sparse=sparse)
D_chunkCULO
D_chunk
D_chunkCULO
D_chunk
D_chunkCULO
D_chunk
M = mahalanobis(D_chunk$z1, D_chunk$z2, A=diag(2), den=h^2 * lambda^2)
M = mahalanobis(D_chunk$z1, D_chunk$z2, A=invS, den=h^2 * lambda^2)
D_chunk
M = mahalanobis(D_chunk$z1, D_chunk$z2, A=invS, den=h^2 * lambda^2)
invS
sqrtinvS
M
invS
h
lambda
lambda =1
M = mahalanobis(D_chunk$z1, D_chunk$z2, A=invS, den=h^2 * lambda^2)
M
MCULO = mahalanobis(D_chunkCULO$z1, D_chunkCULO$z2, A=diag(2), den=h^2 * lambda^2)
M
M - MCULO
# Kernel computation
K = kernelFunction(M)
kernelFunction = defineKernel(kernel.type)
# Kernel computation
K = kernelFunction(M)
K_scaled = sweep(K, 1, lambda^2, "/")
computeTerms(Z, Y, h, detS, K_scaled, type.est)
# Clear workspace and load dependencies
rm(list = ls())
DEBUG = TRUE
source("libs/loadLib.R")
source("libs/codeMunicipalities.R")
suppressPackageStartupMessages(library(plotly))
suppressPackageStartupMessages(library(sm))
suppressPackageStartupMessages(library(mvtnorm))
# ---- Data Generation ----
# Generate random normal data for source distribution
nObs = 10000
set.seed(123)
# Sigma = matrix(c(1, 0, 0, 1), nrow=2)
Sigma = matrix(c(0.75, 0.5, 0.5, 0.75), nrow=2)
X_0_Gauss = mvrnorm(nObs, mu=c(0,0),Sigma = Sigma)
# Create evaluation grid for density estimation and regression
nEval = 10
xGrid = seq(from=min(X_0_Gauss[,1]), to=max(X_0_Gauss[,1]), length.out=round(sqrt(nEval)))
yGrid = seq(from=min(X_0_Gauss[,2]), to=max(X_0_Gauss[,2]), length.out=round(sqrt(nEval)))
x = as.matrix(expand.grid(xGrid, yGrid))
mean = c(0, 0)
trueGaussian = dmvnorm(x, mean, Sigma)
# ---- Density Estimation Tests ----
print("#---- Density Estimation Tests ----")
print("We start by testing the fixed bandwidth density estimation against the sm package")
print("================================================")
print(paste("Number of observations:", nObs))
print(paste("Number of evaluation points:", nEval))
print("================================================")
print("Estimating a standard Gaussian")
bandwidth = 0.5
print(paste(" Gaussian kernel", "bandwidth =", bandwidth))
X = X_0_Gauss
kernel.type="gauss"
method.h=NULL
h=NULL
lambda=NULL
sparse=FALSE
gc=FALSE
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
chunk_size  = 1000
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
type.est = "density"
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
resultEstCULO = kernelMethodCULO(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
resultEstCULO$estimator - resultEst$estimator
# Clear workspace and load dependencies
rm(list = ls())
DEBUG = TRUE
source("libs/loadLib.R")
source("libs/codeMunicipalities.R")
suppressPackageStartupMessages(library(plotly))
suppressPackageStartupMessages(library(sm))
suppressPackageStartupMessages(library(mvtnorm))
# ---- Data Generation ----
# Generate random normal data for source distribution
nObs = 10000
set.seed(123)
# Sigma = matrix(c(1, 0, 0, 1), nrow=2)
Sigma = matrix(c(0.75, 0.5, 0.5, 0.75), nrow=2)
X_0_Gauss = mvrnorm(nObs, mu=c(0,0),Sigma = Sigma)
# Create evaluation grid for density estimation and regression
nEval = 2500
xGrid = seq(from=min(X_0_Gauss[,1]), to=max(X_0_Gauss[,1]), length.out=round(sqrt(nEval)))
yGrid = seq(from=min(X_0_Gauss[,2]), to=max(X_0_Gauss[,2]), length.out=round(sqrt(nEval)))
x = as.matrix(expand.grid(xGrid, yGrid))
mean = c(0, 0)
trueGaussian = dmvnorm(x, mean, Sigma)
# ---- Density Estimation Tests ----
print("#---- Density Estimation Tests ----")
print("We start by testing the fixed bandwidth density estimation against the sm package")
print("================================================")
print(paste("Number of observations:", nObs))
print(paste("Number of evaluation points:", nEval))
print("================================================")
print("Estimating a standard Gaussian")
bandwidth = 0.5
X = X_0_Gauss
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
chunk_size = 1000
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
lambda = NULL
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
type.est = "density"
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
h=NULL
ambda=NULL
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
method.h=NULL
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
kernel.type="gauss"
lambda=NULL
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
sparse=FALSE
gc=FALSE
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
resultEstCULO = kernelMethodCULO(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
resultEst$estimator - resultEstCULO$estimator
setwd("~/Library/CloudStorage/OneDrive-UniversityofPisa/timeSpaceEvolutionEcAct/RVF/R code/Vector Field Estimation/src")
# Clear workspace and load dependencies
#setwd("~/Library/CloudStorage/OneDrive-UniversityofPisa/timeSpaceEvolutionEcAct/RVF/R code/Vector Field Estimation/")
rm(list = ls())
DEBUG = TRUE
source("src/libs/loadLib.R")
library(fields)
library(latex2exp)
# parameters ----
nObs = 1000
nEval = 2500
# data Generation ----
set.seed(1)
X0 = mvrnorm(nObs, mu=c(0,0),Sigma = 0.05*diag(2))
source("src/libs/loadLib.R")
# Clear workspace and load dependencies
setwd("~/Library/CloudStorage/OneDrive-UniversityofPisa/timeSpaceEvolutionEcAct/RVF/R code/Vector Field Estimation/")
rm(list = ls())
DEBUG = TRUE
source("src/libs/loadLib.R")
library(fields)
library(latex2exp)
# parameters ----
nObs = 1000
nEval = 2500
# data Generation ----
set.seed(1)
X0 = mvrnorm(nObs, mu=c(0,0),Sigma = 0.05*diag(2))
# example 3 -- rotation ----
M = matrix(c(cos(pi/2), -sin(pi/2), sin(pi/2), cos(pi/2)),nrow=2,ncol=2)
VF <- function(X){
# X = (x,y), theta = pi/4
return (M %*% X)
}
# apply VF
X1 = X0 + t(apply(X0, 1, VF)) +  matrix(rnorm(2*nObs),nrow=nObs) %*%  matrix(c(0.01,0.005,0.005,0.02),nrow=2) * 10
# eval points
xGrid = seq(from=-1, to=1, length.out=round(sqrt(nEval)))
yGrid = seq(from=-1, to=1, length.out=round(sqrt(nEval)))
x = as.matrix(expand.grid(xGrid, yGrid))
VFx = t(apply(x, 1, VF))
est_field_NW_adaptive = NWfieldAdaptive(X0, X1, x=x, kernel.type="gauss",method.h = "sj",
chunk_size=1000,
sparse=FALSE, gc=TRUE, hOpt = TRUE, h = NULL, alpha=NULL, alphaOpt = TRUE)
# Clear workspace and load dependencies
setwd("~/Library/CloudStorage/OneDrive-UniversityofPisa/timeSpaceEvolutionEcAct/RVF/R code/Vector Field Estimation/")
rm(list = ls())
DEBUG = TRUE
source("src/libs/loadLib.R")
library(fields)
library(latex2exp)
# parameters ----
nObs = 1000
nEval = 2500
# data Generation ----
set.seed(1)
X0 = mvrnorm(nObs, mu=c(0,0),Sigma = 0.05*diag(2))
# example 3 -- rotation ----
M = matrix(c(cos(pi/2), -sin(pi/2), sin(pi/2), cos(pi/2)),nrow=2,ncol=2)
VF <- function(X){
# X = (x,y), theta = pi/4
return (M %*% X)
}
# apply VF
X1 = X0 + t(apply(X0, 1, VF)) +  matrix(rnorm(2*nObs),nrow=nObs) %*%  matrix(c(0.01,0.005,0.005,0.02),nrow=2) * 10
# eval points
xGrid = seq(from=-1, to=1, length.out=round(sqrt(nEval)))
yGrid = seq(from=-1, to=1, length.out=round(sqrt(nEval)))
x = as.matrix(expand.grid(xGrid, yGrid))
VFx = t(apply(x, 1, VF))
est_field_NW_adaptive = NWfieldAdaptive(X0, X1, x=x, kernel.type="gauss",method.h = "sj",
chunk_size=1000,
sparse=FALSE, gc=TRUE, hOpt = TRUE, h = NULL, alpha=NULL, alphaOpt = TRUE)
# Clear workspace and load dependencies
setwd("~/Library/CloudStorage/OneDrive-UniversityofPisa/timeSpaceEvolutionEcAct/RVF/R code/Vector Field Estimation/")
rm(list = ls())
DEBUG = TRUE
source("src/libs/loadLib.R")
library(fields)
library(latex2exp)
# parameters ----
nObs = 1000
nEval = 2500
# data Generation ----
set.seed(1)
X0 = mvrnorm(nObs, mu=c(0,0),Sigma = 0.05*diag(2))
# example 3 -- rotation ----
M = matrix(c(cos(pi/2), -sin(pi/2), sin(pi/2), cos(pi/2)),nrow=2,ncol=2)
VF <- function(X){
# X = (x,y), theta = pi/4
return (M %*% X)
}
# apply VF
X1 = X0 + t(apply(X0, 1, VF)) +  matrix(rnorm(2*nObs),nrow=nObs) %*%  matrix(c(0.01,0.005,0.005,0.02),nrow=2) * 10
# eval points
xGrid = seq(from=-1, to=1, length.out=round(sqrt(nEval)))
yGrid = seq(from=-1, to=1, length.out=round(sqrt(nEval)))
x = as.matrix(expand.grid(xGrid, yGrid))
VFx = t(apply(x, 1, VF))
est_field_NW_adaptive = NWfieldAdaptive(X0, X1, x=x, kernel.type="gauss",method.h = "sj",
chunk_size=1000,
sparse=FALSE, gc=TRUE, hOpt = TRUE, h = NULL, alpha=NULL, alphaOpt = TRUE)
# Clear workspace and load dependencies
setwd("~/Library/CloudStorage/OneDrive-UniversityofPisa/timeSpaceEvolutionEcAct/RVF/R code/Vector Field Estimation/")
rm(list = ls())
DEBUG = TRUE
source("src/libs/loadLib.R")
library(fields)
library(latex2exp)
# parameters ----
nObs = 1000
nEval = 2500
# data Generation ----
set.seed(1)
X0 = mvrnorm(nObs, mu=c(0,0),Sigma = 0.05*diag(2))
# example 3 -- rotation ----
M = matrix(c(cos(pi/2), -sin(pi/2), sin(pi/2), cos(pi/2)),nrow=2,ncol=2)
VF <- function(X){
# X = (x,y), theta = pi/4
return (M %*% X)
}
# apply VF
X1 = X0 + t(apply(X0, 1, VF)) +  matrix(rnorm(2*nObs),nrow=nObs) %*%  matrix(c(0.01,0.005,0.005,0.02),nrow=2) * 10
# eval points
xGrid = seq(from=-1, to=1, length.out=round(sqrt(nEval)))
yGrid = seq(from=-1, to=1, length.out=round(sqrt(nEval)))
x = as.matrix(expand.grid(xGrid, yGrid))
VFx = t(apply(x, 1, VF))
est_field_NW_adaptive = NWfieldAdaptive(X0, X1, x=x, kernel.type="gauss",method.h = "sj",
chunk_size=1000,
sparse=FALSE, gc=TRUE, hOpt = TRUE, h = NULL, alpha=NULL, alphaOpt = TRUE, nGridAlpha=10)
est_field_NW_adaptive$AICc
contour(est_field_NW_adaptive$AICc)
which.min(est_field_NW_adaptive$AICc)
est_field_NW_adaptive$AICc[74]
which.min(est_field_NW_adaptive$AICc,return="index")
which.min(est_field_NW_adaptive$AICc,arr.ind = TRUE)
which(est_field_NW_adaptive$AICc==min(est_field_NW_adaptive$AICc),arr.ind = TRUE)
indMin = which(est_field_NW_adaptive$AICc==min(est_field_NW_adaptive$AICc),arr.ind = TRUE)
est_field_NW_adaptive$h
est_field_NW_adaptive
ls(est_field_NW_adaptive)
est_field_NW_adaptive$alpha
est_field_NW_adaptive$alphaGrid
est_field_NW_adaptive$alphaGrid
indMin
est_field_NW_adaptive$alphaGrid[indMin[2]]
est_field_NW_adaptive$h
est_field_NW_adaptive$lambda
point(est_field_NW_adaptive$h,est_field_NW_adaptive$alpha)
points(est_field_NW_adaptive$h,est_field_NW_adaptive$alpha)
points(est_field_NW_adaptive$h,est_field_NW_adaptive$alpha, pch=19)
# Clear workspace and load dependencies
setwd("~/Library/CloudStorage/OneDrive-UniversityofPisa/timeSpaceEvolutionEcAct/RVF/R code/Vector Field Estimation/")
rm(list = ls())
DEBUG = TRUE
source("src/libs/loadLib.R")
library(fields)
library(latex2exp)
# parameters ----
nObs = 1000
nEval = 2500
# data Generation ----
set.seed(1)
X0 = mvrnorm(nObs, mu=c(0,0),Sigma = 0.05*diag(2))
# example 3 -- rotation ----
M = matrix(c(cos(pi/2), -sin(pi/2), sin(pi/2), cos(pi/2)),nrow=2,ncol=2)
VF <- function(X){
# X = (x,y), theta = pi/4
return (M %*% X)
}
# apply VF
X1 = X0 + t(apply(X0, 1, VF)) +  matrix(rnorm(2*nObs),nrow=nObs) %*%  matrix(c(0.01,0.005,0.005,0.02),nrow=2) * 10
# eval points
xGrid = seq(from=-1, to=1, length.out=round(sqrt(nEval)))
yGrid = seq(from=-1, to=1, length.out=round(sqrt(nEval)))
x = as.matrix(expand.grid(xGrid, yGrid))
VFx = t(apply(x, 1, VF))
est_field_NW_adaptive = NWfieldAdaptive(X0, X1, x=x, kernel.type="gauss",method.h = "sj",
chunk_size=1000,
sparse=FALSE, gc=TRUE, hOpt = TRUE, h = NULL, alpha=NULL, alphaOpt = TRUE, nGridAlpha=10)
contour(x=est_field_NW_adaptive$hGrid,  y=est_field_NW_adaptive$alphaGrid, z=est_field_NW_adaptive$AICc)
which(est_field_NW_adaptive$AICc==min(est_field_NW_adaptive$AICc),arr.ind = TRUE)
#indMin = which(est_field_NW_adaptive$AICc==min(est_field_NW_adaptive$AICc),arr.ind = TRUE)
points(est_field_NW_adaptive$h,est_field_NW_adaptive$alpha, pch=19)
est_field_NW_adaptive$hGrid[4]
est_field_NW_adaptive$h
image(x=est_field_NW_adaptive$hGrid,  y=est_field_NW_adaptive$alphaGrid, z=est_field_NW_adaptive$AICc)
contour
contour(x=est_field_NW_adaptive$hGrid,  y=est_field_NW_adaptive$alphaGrid, z=est_field_NW_adaptive$AICc)
est_field_NW_adaptive$hGrid
est_field_NW_adaptive$alphaGrid
#indMin = which(est_field_NW_adaptive$AICc==min(est_field_NW_adaptive$AICc),arr.ind = TRUE)
points(est_field_NW_adaptive$alpha, est_field_NW_adaptive$h, pch=19)
est_field_NW_adaptive$alpha
est_field_NW_adaptive$h
est_field_NW_adaptive$alphaGrid
est_field_NW_adaptive$alpha
#indMin = which(est_field_NW_adaptive$AICc==min(est_field_NW_adaptive$AICc),arr.ind = TRUE)
points(est_field_NW_adaptive$h,est_field_NW_adaptive$alpha, pch=19)
