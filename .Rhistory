xGrid = seq(from=min(X_0_Gauss[,1]), to=max(X_0_Gauss[,1]), length.out=round(sqrt(nEval)))
yGrid = seq(from=min(X_0_Gauss[,2]), to=max(X_0_Gauss[,2]), length.out=round(sqrt(nEval)))
x = as.matrix(expand.grid(xGrid, yGrid))
mean = c(0, 0)
trueGaussian = dmvnorm(x, mean, Sigma)
# ---- Density Estimation Tests ----
print("#---- Density Estimation Tests ----")
print("We start by testing the fixed bandwidth density estimation against the sm package")
print("================================================")
print(paste("Number of observations:", nObs))
print(paste("Number of evaluation points:", nEval))
print("================================================")
print("Estimating a standard Gaussian")
bandwidth = 0.5
print(paste(" Gaussian kernel", "bandwidth =", bandwidth))
X = X_0_Gauss
kernel.type="gauss"
method.h=NULL
h=NULL
lambda=NULL
sparse=FALSE
gc=FALSE
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
chunk_size  = 1000
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
type.est = "density"
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
resultEstCULO = kernelMethodCULO(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
resultEstCULO$estimator - resultEst$estimator
# Clear workspace and load dependencies
rm(list = ls())
DEBUG = TRUE
source("libs/loadLib.R")
source("libs/codeMunicipalities.R")
suppressPackageStartupMessages(library(plotly))
suppressPackageStartupMessages(library(sm))
suppressPackageStartupMessages(library(mvtnorm))
# ---- Data Generation ----
# Generate random normal data for source distribution
nObs = 10000
set.seed(123)
# Sigma = matrix(c(1, 0, 0, 1), nrow=2)
Sigma = matrix(c(0.75, 0.5, 0.5, 0.75), nrow=2)
X_0_Gauss = mvrnorm(nObs, mu=c(0,0),Sigma = Sigma)
# Create evaluation grid for density estimation and regression
nEval = 2500
xGrid = seq(from=min(X_0_Gauss[,1]), to=max(X_0_Gauss[,1]), length.out=round(sqrt(nEval)))
yGrid = seq(from=min(X_0_Gauss[,2]), to=max(X_0_Gauss[,2]), length.out=round(sqrt(nEval)))
x = as.matrix(expand.grid(xGrid, yGrid))
mean = c(0, 0)
trueGaussian = dmvnorm(x, mean, Sigma)
# ---- Density Estimation Tests ----
print("#---- Density Estimation Tests ----")
print("We start by testing the fixed bandwidth density estimation against the sm package")
print("================================================")
print(paste("Number of observations:", nObs))
print(paste("Number of evaluation points:", nEval))
print("================================================")
print("Estimating a standard Gaussian")
bandwidth = 0.5
X = X_0_Gauss
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
chunk_size = 1000
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
lambda = NULL
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
type.est = "density"
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
h=NULL
ambda=NULL
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
method.h=NULL
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
kernel.type="gauss"
lambda=NULL
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
sparse=FALSE
gc=FALSE
resultEst = kernelMethod(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
resultEstCULO = kernelMethodCULO(X=X,x=x,nEval=nEval,kernel.type=kernel.type,D=D,
method.h=method.h,h=h,lambda=lambda,
sparse=sparse,gc=gc,chunk_size=chunk_size,type.est=type.est)
resultEst$estimator - resultEstCULO$estimator
setwd("~/Library/CloudStorage/OneDrive-UniversityofPisa/timeSpaceEvolutionEcAct/RVF/R code/Vector Field Estimation/src")
# Clear workspace and load dependencies
setwd("~/Library/CloudStorage/OneDrive-UniversityofPisa/timeSpaceEvolutionEcAct/RVF/R code/Vector Field Estimation/")
rm(list = ls())
DEBUG = TRUE
source("src/libs/loadLib.R")
library(fields)
library(latex2exp)
# parameters ----
nObs = 1000
nEval = 2500
# data Generation ----
set.seed(1)
X0 = mvrnorm(nObs, mu=c(0,0),Sigma = 0.05*diag(2))
# compute min and max distance between points
# get distances component wise
#distances = computeDcomponents(X0, X0)
#distance_matrix = sqrt(mahalanobis(distances$z1, distances$z2, A = diag(2), 1))
# print the non zero minimum and maximum distance
#print(min(distance_matrix[distance_matrix > 0]))
#print(max(distance_matrix[distance_matrix > 0]))
# example 1 - double well ----
# VF <- function(X){
#     # X = (x,y)
#     # U(X) = x^4 - x^2 + y^2
#     # VF(X) = -grad U(X) = -(4x^3 - 2x, 2y)
#     return( -0.1*c(4*X[1]^3 - 2*X[1], 2*X[2]) )
# }
# example 2 -- single well ----
# VF <- function(X){
#     # X = (x,y)
#     # U(X) = x^2 + y^2
#     # VF(X) = -grad U(X) = -(2x, 2y)
#     return( -0.01*c(2*X[1], 2*X[2]) )
# }
# example 3 -- rotation ----
M = matrix(c(cos(pi/2), -sin(pi/2), sin(pi/2), cos(pi/2)),nrow=2,ncol=2)
VF <- function(X){
# X = (x,y), theta = pi/4
return (M %*% X)
}
# apply VF
X1 = X0 + t(apply(X0, 1, VF)) +  matrix(rnorm(2*nObs),nrow=nObs) %*%  matrix(c(0.01,0.005,0.005,0.02),nrow=2) * 10
# eval points
xGrid = seq(from=-1, to=1, length.out=round(sqrt(nEval)))
yGrid = seq(from=-1, to=1, length.out=round(sqrt(nEval)))
x = as.matrix(expand.grid(xGrid, yGrid))
VFx = t(apply(x, 1, VF))
# stima ----
est_field_LL_opt = LLfield(X0, X1, x=X0 , kernel.type="gauss", method.h = NULL,
chunk_size=1000,
sparse=FALSE, gc=TRUE, hOpt = FALSE, h = 0.03)
# Find rows where the estimator has NA values
na_rows <- which(is.na(est_field_LL_opt$estimator[,1]) | is.na(est_field_LL_opt$estimator[,2]))
# Print the number of rows with NA values
cat("Number of rows with NA values in the estimator:", length(na_rows), "\n")
cat("X0 values corresponding to NA estimator values:\n")
print(X0[na_rows, , drop = FALSE])
# Clear workspace and load dependencies
setwd("~/Library/CloudStorage/OneDrive-UniversityofPisa/timeSpaceEvolutionEcAct/RVF/R code/Vector Field Estimation/")
rm(list = ls())
DEBUG = TRUE
source("src/libs/loadLib.R")
library(fields)
library(latex2exp)
# parameters ----
nObs = 1000
nEval = 2500
# data Generation ----
set.seed(1)
X0 = mvrnorm(nObs, mu=c(0,0),Sigma = 0.05*diag(2))
# compute min and max distance between points
# get distances component wise
#distances = computeDcomponents(X0, X0)
#distance_matrix = sqrt(mahalanobis(distances$z1, distances$z2, A = diag(2), 1))
# print the non zero minimum and maximum distance
#print(min(distance_matrix[distance_matrix > 0]))
#print(max(distance_matrix[distance_matrix > 0]))
# example 1 - double well ----
# VF <- function(X){
#     # X = (x,y)
#     # U(X) = x^4 - x^2 + y^2
#     # VF(X) = -grad U(X) = -(4x^3 - 2x, 2y)
#     return( -0.1*c(4*X[1]^3 - 2*X[1], 2*X[2]) )
# }
# example 2 -- single well ----
# VF <- function(X){
#     # X = (x,y)
#     # U(X) = x^2 + y^2
#     # VF(X) = -grad U(X) = -(2x, 2y)
#     return( -0.01*c(2*X[1], 2*X[2]) )
# }
# example 3 -- rotation ----
M = matrix(c(cos(pi/2), -sin(pi/2), sin(pi/2), cos(pi/2)),nrow=2,ncol=2)
VF <- function(X){
# X = (x,y), theta = pi/4
return (M %*% X)
}
# apply VF
X1 = X0 + t(apply(X0, 1, VF)) +  matrix(rnorm(2*nObs),nrow=nObs) %*%  matrix(c(0.01,0.005,0.005,0.02),nrow=2) * 10
# eval points
xGrid = seq(from=-1, to=1, length.out=round(sqrt(nEval)))
yGrid = seq(from=-1, to=1, length.out=round(sqrt(nEval)))
x = as.matrix(expand.grid(xGrid, yGrid))
VFx = t(apply(x, 1, VF))
# stima ----
est_field_LL_opt = LLfield(X0, X1, x=X0 , kernel.type="gauss", method.h = NULL,
chunk_size=1000,
sparse=FALSE, gc=TRUE, hOpt = FALSE, h = 0.03)
# Find rows where the estimator has NA values
na_rows <- which(is.na(est_field_LL_opt$estimator[,1]) | is.na(est_field_LL_opt$estimator[,2]))
# Print the number of rows with NA values
cat("Number of rows with NA values in the estimator:", length(na_rows), "\n")
cat("X0 values corresponding to NA estimator values:\n")
print(X0[na_rows, , drop = FALSE])
# Plot X0 in a scatter plot
plot(X0, pch = 19, col = "blue")
# Add a red circle at the points where the estimator is NA
points(X0[na_rows, , drop = FALSE], pch = 19, col = "red")
?cov
est_field_LL_opt = LLfield(X0, X1, x=X0 , kernel.type="gauss", method.h = NULL,
chunk_size=1000,
sparse=FALSE, gc=TRUE, hOpt = TRUE, h = 0.03)
est_field_LL_opt = LLfield(X0, X1, x=X0 , kernel.type="gauss", method.h = NULL,
chunk_size=1000,
sparse=FALSE, gc=TRUE, hOpt = TRUE, h = NULL)
est_field_LL_opt = LLfield(X0, X1, x=X0 , kernel.type="gauss", method.h = NULL,
chunk_size=1000,
sparse=FALSE, gc=TRUE, hOpt = FALSE, h = 0.03)
# Clear workspace and load dependencies
setwd("~/Library/CloudStorage/OneDrive-UniversityofPisa/timeSpaceEvolutionEcAct/RVF/R code/Vector Field Estimation/")
rm(list = ls())
DEBUG = TRUE
source("src/libs/loadLib.R")
library(fields)
library(latex2exp)
# parameters ----
nObs = 1000
nEval = 2500
# data Generation ----
set.seed(1)
X0 = mvrnorm(nObs, mu=c(0,0),Sigma = 0.05*diag(2))
# compute min and max distance between points
# get distances component wise
#distances = computeDcomponents(X0, X0)
#distance_matrix = sqrt(mahalanobis(distances$z1, distances$z2, A = diag(2), 1))
# print the non zero minimum and maximum distance
#print(min(distance_matrix[distance_matrix > 0]))
#print(max(distance_matrix[distance_matrix > 0]))
# example 1 - double well ----
# VF <- function(X){
#     # X = (x,y)
#     # U(X) = x^4 - x^2 + y^2
#     # VF(X) = -grad U(X) = -(4x^3 - 2x, 2y)
#     return( -0.1*c(4*X[1]^3 - 2*X[1], 2*X[2]) )
# }
# example 2 -- single well ----
# VF <- function(X){
#     # X = (x,y)
#     # U(X) = x^2 + y^2
#     # VF(X) = -grad U(X) = -(2x, 2y)
#     return( -0.01*c(2*X[1], 2*X[2]) )
# }
# example 3 -- rotation ----
M = matrix(c(cos(pi/2), -sin(pi/2), sin(pi/2), cos(pi/2)),nrow=2,ncol=2)
VF <- function(X){
# X = (x,y), theta = pi/4
return (M %*% X)
}
# apply VF
X1 = X0 + t(apply(X0, 1, VF)) +  matrix(rnorm(2*nObs),nrow=nObs) %*%  matrix(c(0.01,0.005,0.005,0.02),nrow=2) * 10
# eval points
xGrid = seq(from=-1, to=1, length.out=round(sqrt(nEval)))
yGrid = seq(from=-1, to=1, length.out=round(sqrt(nEval)))
x = as.matrix(expand.grid(xGrid, yGrid))
VFx = t(apply(x, 1, VF))
# stima ----
est_field_LL_opt = LLfield(X0, X1, x=X0 , kernel.type="gauss", method.h = NULL,
chunk_size=1000,
sparse=FALSE, gc=TRUE, hOpt = TRUE, h = NULL)
source("~/Library/CloudStorage/OneDrive-UniversityofPisa/timeSpaceEvolutionEcAct/RVF/R code/Vector Field Estimation/src/libs/localLinear.R", echo=TRUE)
# stima ----
est_field_LL_opt = LLfield(X0, X1, x=X0 , kernel.type="gauss", method.h = NULL,
chunk_size=1000,
sparse=FALSE, gc=TRUE, hOpt = TRUE, h = NULL)
matrix(rnorm(200),nrows=100)
A = matrix(rnorm(200),nrow=100)
A
cov(A)
det(cov(A))
det(cov(A,na.rm=T))
A
A [1,10] = NA
A [10,1] = NA
A
cov(A)
cov(A,use=na.or.complete)
cov(A,use="na.or.complete")
cov(A,use=complete.obs)
cov(A,use="complete.obs")
# Clear workspace and load dependencies
setwd("~/Library/CloudStorage/OneDrive-UniversityofPisa/timeSpaceEvolutionEcAct/RVF/R code/Vector Field Estimation/")
rm(list = ls())
DEBUG = TRUE
source("src/libs/loadLib.R")
library(fields)
library(latex2exp)
# parameters ----
nObs = 1000
nEval = 2500
# data Generation ----
set.seed(1)
X0 = mvrnorm(nObs, mu=c(0,0),Sigma = 0.05*diag(2))
# compute min and max distance between points
# get distances component wise
#distances = computeDcomponents(X0, X0)
#distance_matrix = sqrt(mahalanobis(distances$z1, distances$z2, A = diag(2), 1))
# print the non zero minimum and maximum distance
#print(min(distance_matrix[distance_matrix > 0]))
#print(max(distance_matrix[distance_matrix > 0]))
# example 1 - double well ----
# VF <- function(X){
#     # X = (x,y)
#     # U(X) = x^4 - x^2 + y^2
#     # VF(X) = -grad U(X) = -(4x^3 - 2x, 2y)
#     return( -0.1*c(4*X[1]^3 - 2*X[1], 2*X[2]) )
# }
# example 2 -- single well ----
# VF <- function(X){
#     # X = (x,y)
#     # U(X) = x^2 + y^2
#     # VF(X) = -grad U(X) = -(2x, 2y)
#     return( -0.01*c(2*X[1], 2*X[2]) )
# }
# example 3 -- rotation ----
M = matrix(c(cos(pi/2), -sin(pi/2), sin(pi/2), cos(pi/2)),nrow=2,ncol=2)
VF <- function(X){
# X = (x,y), theta = pi/4
return (M %*% X)
}
# apply VF
X1 = X0 + t(apply(X0, 1, VF)) +  matrix(rnorm(2*nObs),nrow=nObs) %*%  matrix(c(0.01,0.005,0.005,0.02),nrow=2) * 10
# eval points
xGrid = seq(from=-1, to=1, length.out=round(sqrt(nEval)))
yGrid = seq(from=-1, to=1, length.out=round(sqrt(nEval)))
x = as.matrix(expand.grid(xGrid, yGrid))
VFx = t(apply(x, 1, VF))
# stima ----
est_field_LL_opt = LLfield(X0, X1, x=X0 , kernel.type="gauss", method.h = NULL,
chunk_size=1000,
sparse=FALSE, gc=TRUE, hOpt = TRUE, h = NULL)
partialTraceHLL
# Clear workspace and load dependencies
setwd("~/Library/CloudStorage/OneDrive-UniversityofPisa/timeSpaceEvolutionEcAct/RVF/R code/Vector Field Estimation/")
rm(list = ls())
DEBUG = TRUE
source("src/libs/loadLib.R")
library(fields)
library(latex2exp)
# parameters ----
nObs = 1000
nEval = 2500
# data Generation ----
set.seed(1)
X0 = mvrnorm(nObs, mu=c(0,0),Sigma = 0.05*diag(2))
# compute min and max distance between points
# get distances component wise
#distances = computeDcomponents(X0, X0)
#distance_matrix = sqrt(mahalanobis(distances$z1, distances$z2, A = diag(2), 1))
# print the non zero minimum and maximum distance
#print(min(distance_matrix[distance_matrix > 0]))
#print(max(distance_matrix[distance_matrix > 0]))
# example 1 - double well ----
# VF <- function(X){
#     # X = (x,y)
#     # U(X) = x^4 - x^2 + y^2
#     # VF(X) = -grad U(X) = -(4x^3 - 2x, 2y)
#     return( -0.1*c(4*X[1]^3 - 2*X[1], 2*X[2]) )
# }
# example 2 -- single well ----
# VF <- function(X){
#     # X = (x,y)
#     # U(X) = x^2 + y^2
#     # VF(X) = -grad U(X) = -(2x, 2y)
#     return( -0.01*c(2*X[1], 2*X[2]) )
# }
# example 3 -- rotation ----
M = matrix(c(cos(pi/2), -sin(pi/2), sin(pi/2), cos(pi/2)),nrow=2,ncol=2)
VF <- function(X){
# X = (x,y), theta = pi/4
return (M %*% X)
}
# apply VF
X1 = X0 + t(apply(X0, 1, VF)) +  matrix(rnorm(2*nObs),nrow=nObs) %*%  matrix(c(0.01,0.005,0.005,0.02),nrow=2) * 10
# eval points
xGrid = seq(from=-1, to=1, length.out=round(sqrt(nEval)))
yGrid = seq(from=-1, to=1, length.out=round(sqrt(nEval)))
x = as.matrix(expand.grid(xGrid, yGrid))
VFx = t(apply(x, 1, VF))
# stima ----
est_field_LL_opt = LLfield(X0, X1, x=X0 , kernel.type="gauss", method.h = NULL,
chunk_size=1000,
sparse=FALSE, gc=TRUE, hOpt = TRUE, h = NULL)
# Clear workspace and load dependencies
setwd("~/Library/CloudStorage/OneDrive-UniversityofPisa/timeSpaceEvolutionEcAct/RVF/R code/Vector Field Estimation/")
rm(list = ls())
DEBUG = TRUE
source("src/libs/loadLib.R")
library(fields)
library(latex2exp)
# parameters ----
nObs = 1000
nEval = 2500
# data Generation ----
set.seed(1)
X0 = mvrnorm(nObs, mu=c(0,0),Sigma = 0.05*diag(2))
# compute min and max distance between points
# get distances component wise
#distances = computeDcomponents(X0, X0)
#distance_matrix = sqrt(mahalanobis(distances$z1, distances$z2, A = diag(2), 1))
# print the non zero minimum and maximum distance
#print(min(distance_matrix[distance_matrix > 0]))
#print(max(distance_matrix[distance_matrix > 0]))
# example 1 - double well ----
# VF <- function(X){
#     # X = (x,y)
#     # U(X) = x^4 - x^2 + y^2
#     # VF(X) = -grad U(X) = -(4x^3 - 2x, 2y)
#     return( -0.1*c(4*X[1]^3 - 2*X[1], 2*X[2]) )
# }
# example 2 -- single well ----
# VF <- function(X){
#     # X = (x,y)
#     # U(X) = x^2 + y^2
#     # VF(X) = -grad U(X) = -(2x, 2y)
#     return( -0.01*c(2*X[1], 2*X[2]) )
# }
# example 3 -- rotation ----
M = matrix(c(cos(pi/2), -sin(pi/2), sin(pi/2), cos(pi/2)),nrow=2,ncol=2)
VF <- function(X){
# X = (x,y), theta = pi/4
return (M %*% X)
}
# apply VF
X1 = X0 + t(apply(X0, 1, VF)) +  matrix(rnorm(2*nObs),nrow=nObs) %*%  matrix(c(0.01,0.005,0.005,0.02),nrow=2) * 10
# eval points
xGrid = seq(from=-1, to=1, length.out=round(sqrt(nEval)))
yGrid = seq(from=-1, to=1, length.out=round(sqrt(nEval)))
x = as.matrix(expand.grid(xGrid, yGrid))
VFx = t(apply(x, 1, VF))
# stima ----
est_field_LL_opt = LLfield(X0, X1, x=X0 , kernel.type="gauss", method.h = NULL,
chunk_size=1000,
sparse=FALSE, gc=TRUE, hOpt = TRUE, h = NULL)
# Clear workspace and load dependencies
setwd("~/Library/CloudStorage/OneDrive-UniversityofPisa/timeSpaceEvolutionEcAct/RVF/R code/Vector Field Estimation/")
rm(list = ls())
DEBUG = TRUE
source("src/libs/loadLib.R")
library(fields)
library(latex2exp)
# parameters ----
nObs = 1000
nEval = 2500
# data Generation ----
set.seed(1)
X0 = mvrnorm(nObs, mu=c(0,0),Sigma = 0.05*diag(2))
# compute min and max distance between points
# get distances component wise
#distances = computeDcomponents(X0, X0)
#distance_matrix = sqrt(mahalanobis(distances$z1, distances$z2, A = diag(2), 1))
# print the non zero minimum and maximum distance
#print(min(distance_matrix[distance_matrix > 0]))
#print(max(distance_matrix[distance_matrix > 0]))
# example 1 - double well ----
# VF <- function(X){
#     # X = (x,y)
#     # U(X) = x^4 - x^2 + y^2
#     # VF(X) = -grad U(X) = -(4x^3 - 2x, 2y)
#     return( -0.1*c(4*X[1]^3 - 2*X[1], 2*X[2]) )
# }
# example 2 -- single well ----
# VF <- function(X){
#     # X = (x,y)
#     # U(X) = x^2 + y^2
#     # VF(X) = -grad U(X) = -(2x, 2y)
#     return( -0.01*c(2*X[1], 2*X[2]) )
# }
# example 3 -- rotation ----
M = matrix(c(cos(pi/2), -sin(pi/2), sin(pi/2), cos(pi/2)),nrow=2,ncol=2)
VF <- function(X){
# X = (x,y), theta = pi/4
return (M %*% X)
}
# apply VF
X1 = X0 + t(apply(X0, 1, VF)) +  matrix(rnorm(2*nObs),nrow=nObs) %*%  matrix(c(0.01,0.005,0.005,0.02),nrow=2) * 10
# eval points
xGrid = seq(from=-1, to=1, length.out=round(sqrt(nEval)))
yGrid = seq(from=-1, to=1, length.out=round(sqrt(nEval)))
x = as.matrix(expand.grid(xGrid, yGrid))
VFx = t(apply(x, 1, VF))
# stima ----
est_field_LL_opt = NWfield(X0, X1, x=X0 , kernel.type="gauss", method.h = NULL,
chunk_size=1000,
sparse=FALSE, gc=TRUE, hOpt = TRUE, h = NULL)
